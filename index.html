<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="q">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="q">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="q">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/head1.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/" title="Hi Mate">逆拂</a></h1>
        </hgroup>

        
        <p class="header-subtitle">生命是长期而持续的积累</p>
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">博客首页</a></li>
                        
                            <li><a href="/works">作品展示</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl github" target="_blank" href="https://github.com/Neef6" title="github">github</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://luuman.github.io/">name</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">爱运动、爱交友、爱旅行、喜欢接触新鲜事物、迎接新的挑战，更爱游离于错综复杂的编码与逻辑中</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">逆拂</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head1.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">逆拂</a></h1>
            </hgroup>
            
            <p class="header-subtitle">生命是长期而持续的积累</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">博客首页</a></li>
                
                    <li><a href="/works">作品展示</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="github" target="_blank" href="https://github.com/Neef6" title="github">github</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-begin" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/13/begin/" class="article-date">
      <time datetime="2018-02-13T08:11:31.000Z" itemprop="datePublished">2018-02-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>放假了ß</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-数据不一致问题分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/13/数据不一致问题分析/" class="article-date">
      <time datetime="2018-02-13T07:12:27.000Z" itemprop="datePublished">2018-02-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="HDFS关于写入数据过程临近结束的处理"><a href="#HDFS关于写入数据过程临近结束的处理" class="headerlink" title="HDFS关于写入数据过程临近结束的处理"></a>HDFS关于写入数据过程临近结束的处理</h1><h2 id="由一个log引发的分析"><a href="#由一个log引发的分析" class="headerlink" title="由一个log引发的分析"></a>由一个log引发的分析</h2><p>环境：hdfs-2.4版本</p>
<p>run log：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2017-12-30 15:07:42,396 INFO org.apache.hadoop.hdfs.server.namenode.FSNamesystem: BLOCK* checkFileProgress: blk_10968682121_9934420449&#123;blockUCState=COMMITTED, primaryNodeIndex=-1, replicas=[ReplicaUnderConstruction[[DISK]DS-49e57c7a-53cd-44ab-b7fc-f042699bf765:NORMAL|RBW], ReplicaUnderConstruction[[DISK]DS-d6a8cc53-f53a-4887-801a-acd66c0a0efd:NORMAL|RBW], ReplicaUnderConstruction[[DISK]DS-d1eb830f-6deb-475f-89a6-68be0849f8ca:NORMAL|RBW]]&#125; has not reached minimal replication 1</span><br><span class="line"></span><br><span class="line">2017-12-30 15:07:42,491 INFO BlockStateChange: BLOCK NameSystem.addToCorruptReplicasMap: blk_10968682121 added as corrupt on 10.104.74.17:50010 by /10.104.74.17 because block is COMMITTED and reported length 132928 does not match length in block map 11632 block is COMMITTED and reported length  does not match length in block map</span><br></pre></td></tr></table></figure>
<p>名词分析：</p>
<ul>
<li>COMMITTED:block的一种状态，意味着已经commited，还未向NN汇报过的block状态。</li>
<li>RBW表示replication正在被写入状态。</li>
</ul>
<p>根据log打印的提示信息找到相对应的代码（。。省略）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//the first block report received from a DN after it registers</span></span><br><span class="line">processFirstBlockReport（）&#123;</span><br><span class="line">checkReplicaCorrupt（）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> BlockToMarkCorrupt <span class="title">checkReplicaCorrupt</span><span class="params">(。。)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(reportedState) &#123;</span><br><span class="line">    <span class="keyword">case</span> COMMITTED:</span><br><span class="line">    。。</span><br><span class="line">	 <span class="keyword">else</span> <span class="keyword">if</span> (storedBlock.getNumBytes() != reported.getNumBytes()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BlockToMarkCorrupt(storedBlock,</span><br><span class="line">            <span class="string">"block is "</span> + ucState + <span class="string">" and reported length "</span> +</span><br><span class="line">            reported.getNumBytes() + <span class="string">" does not match "</span> +</span><br><span class="line">            <span class="string">"length in block map "</span> + storedBlock.getNumBytes(),</span><br><span class="line">            Reason.SIZE_MISMATCH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据代码，加上注释的分析，问题发生的时间点应该：client写数据流程中，client收到ack回复后请求NN complete file，然后NN等待DN的block report。进行info检验时候报的问题。</p>
<p>存在的几个问题：</p>
<ol>
<li>reported length  does not match length in block map</li>
<li>reported length 132928    132928/1024=129.81K</li>
<li>block map 11632                 11632/1024=11.36K</li>
</ol>
<p>## </p>
<h2 id="代码回朔"><a href="#代码回朔" class="headerlink" title="代码回朔"></a>代码回朔</h2><h3 id="分析此时间段hdfs要做的工作："><a href="#分析此时间段hdfs要做的工作：" class="headerlink" title="分析此时间段hdfs要做的工作："></a>分析此时间段hdfs要做的工作：</h3><ol>
<li>DN上replications继续写入，写完client收到ack,dfs向NN汇报。</li>
<li>client告知NN文件大小修改block map，block location信息并请求complete file。</li>
<li>NN等待DN汇报。DN通过heartBeat汇报上来，NN检查信息。</li>
</ol>
<h3 id="程序流程中要关注的几个问题："><a href="#程序流程中要关注的几个问题：" class="headerlink" title="程序流程中要关注的几个问题："></a>程序流程中要关注的几个问题：</h3><ol>
<li>更改blockMap的几个时间段</li>
<li>client向NN发送block的大小的由来</li>
<li>DN向告知clientblock大小和之后汇报block大小之间有什么操作</li>
<li>不管是complete还是增量汇报report，针对的都是</li>
<li>client   complete 修改blockMap。查看汇报blockmap之后有哪些check步骤</li>
</ol>
<h3 id="client-block写入流程分析"><a href="#client-block写入流程分析" class="headerlink" title="client block写入流程分析"></a>client block写入流程分析</h3><p>在hdfs数据写入过程中，client端会创建一个DFSOutputStream对象，并启动一个其内部类DataStreamer守护线程和ResponseProcessor守护线程，执行packet的分发。</p>
<p>DataStreamer负责建立数据管道（pipline）,并将packet发送到数据流管道的第一台datanode上。</p>
<p>（分发逻辑简单来说就是将数据切分成包放入linkList -dataQue中</p>
<p>当DN在执行3备份成功的时候，第一台DN会收到下游的ack，表示3副本已经写入成功。之后</p>
<p>DataStreamer会关闭响应的response）</p>
<p>ResponseProcessor负责响应下游的ack状态码，判断ack的状态。如果失败，记录下datanode的索引（errorIndex &amp; restartIndex），并设置错误状态（hasError）。如果成功则将packet从ackQue（LinkList）中移除。如果发送过程中出现错误，packet会放回dataQueue中等待重新发送。client端会用新的datanode替换数据流管道中出错的datanode（执行替换的条件：当前数据节点的数目小于所需要的副本数除以2，以及在append/flush状态下，当前数据节点的数目小于所需要的副本?不替换异常的Datanode如何处理？）。</p>
<p>包含数据的packet发送完之后会发送一个空包，用来标示所有的数据已经发送完毕（直接新建一个信息从第一台datanode返回给client不行么？），之后会调用endBlock（）执行清理。</p>
<p>当写入完成，会调用DFSOutputStream.close（）（触发条件？）方法。首先将输出流中缓存的数据写成数据包，并将还未发送的packet放入dataQueue，再构造一个空包用于标示发送完成。（和上一个空包的区别？）。</p>
<p>之后complete file，向NN提交这个文件。传递最后一个block信息给NN，FSNameSystem</p>
<p>处理。获得写锁，然后构建Inode，添加信息。然后更改lastBlock的状态，将completed转化为complete。（其中还有些线程线程进程，副本的冗余等的线程级别如何处理），然后向blockMap中更新block信息。</p>
<p>之后释放租约。</p>
<p>出错的处理：</p>
<p>租约出错的话会调用commitOrCompleteLastBlock （）提交block，关闭租约过期的文件</p>
<p>参数：lastblock</p>
<p>DFSOutputStream  close（）</p>
<p>DFSOutputStream  complete -》protocol -》NamenodeServer complete -&gt; FSNamesystem completeFileInternal -&gt;check iNode， commitOrCompleteLastBlock block已经complete状态-&gt; blockManager completeBlock -》convertToCompleteBlock -》blocksMap replaceBlock（）</p>
<p>结果：会把最后一个block转化为complete状态并添加到blockMap中</p>
<p>汇报block的来源：</p>
<p>文件就只有一个block的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">stream run（）&#123;</span><br><span class="line">	dataQueue.wait to send</span><br><span class="line">&#125;</span><br><span class="line">newStreamForCreate()&#123;</span><br><span class="line">    <span class="keyword">final</span> DFSOutputStream out = <span class="keyword">new</span> DFSOutputStream(dfsClient, src, stat,</span><br><span class="line">        flag, progress, checksum, favoredNodes);</span><br><span class="line">  out.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExtendedBlock lastBlock = streamer.getBlock();</span><br></pre></td></tr></table></figure>
<p>当前block不考虑是追加的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setupPipelineForAppendOrRecovery</span><br></pre></td></tr></table></figure>
<h3 id="DN-report（增量）-过程分析"><a href="#DN-report（增量）-过程分析" class="headerlink" title="DN report（增量） 过程分析"></a>DN report（增量） 过程分析</h3><p>（client写数据写完,nn应该是等dn汇报，这个汇报应该是等的周期性的汇报，而不是立即。但是和逻辑有点冲突？增量块也要30s这不对把）</p>
<p>(通过代理，集群模式下代理的使用？这个是rpc)</p>
<p>DN 会构建BPServiceActor线程与NN通信。BPServiceActor负责向NN发送心跳，增量块、全量、缓存块的汇报。</p>
<p>过程：DN有个bp后台线程，会通过heartbeat做增量汇报。DN会通过一个Map-pendingIncrementalBRperStorage存储block状态。Map中有数据块状态发生改变，在周期要汇报的时候发送给NN。</p>
<p> 这个reportReceivedDeletedBlocks()方法的大致处理流程如下：</p>
<p>创建一个存储StorageReceivedDeletedBlocks的ArrayList列表reports，是对pendingIncrementalBRperStorage存储的在上一次report之后block更改信息的重新组合封装。</p>
<p>​        2、使用synchronized对pendingIncrementalBRperStorage进行同步，遍历pendingIncrementalBRperStorage：</p>
<p>​              2.1、取出每个DatanodeStorage、PerStoragePendingIncrementalBR进行处理；</p>
<p>​              2.2、如果perStorageMap中存在发生变化的数据块，发送新接收的或者已删除的数据块ID给NameNode：</p>
<p>​                       2.2.1、从perStorageMap中获得ReceivedDeletedBlockInfo数组；</p>
<p>​                       2.2.3、将根据DatanodeStorage和ReceivedDeletedBlockInfo数组构造的StorageReceivedDeletedBlocks加入reports列表；</p>
<p>​        3、立即汇报的标志位sendImmediateIBR设置为false；</p>
<p>​        4、reports大小为0的话，直接返回null；</p>
<p>​        5、发送是否成功的标志位success初始化为false；</p>
<p>​        6、通过NameNode代理bpNamenode的blockReceivedAndDeleted()方法，将新接收的或者已删除的数据块汇报给NameNode，汇报的信息包括：</p>
<p>​               6.1、数据节点注册信息DatanodeRegistration；</p>
<p>​               6.2、数据块池ID；</p>
<p>​               6.3、需要汇报的数据块及其状态信息列表StorageReceivedDeletedBlocks；</p>
<p>​        7、 发送是否成功的标志位success设置为true；</p>
<p>​        8、汇报不成功的话，遍历reports：</p>
<p>​               8.1、将数据块再放回到perStorageMap；</p>
<p>​               8.2、立即汇报的标志位sendImmediateIBR设置为true。</p>
<p>NN</p>
<p>如果是已被删除的数据块，调用removeStoredBlock()方法在NameNode中移除node对应数据块元信息。如果是已接收的数据块调用addBlock()方法在NameNode中添加数据块元信息。如果是正在接收的数据块，调用processAndHandleReportedBlock()方法在NameNode中处理正在接收的数据块。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Report the list blocks to the Namenode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;DatanodeCommand&gt; <span class="title">blockReport</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">//一种是立即，一种是周期report</span></span><br><span class="line">  reportReceivedDeletedBlocks();</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Send the reports to the NN.</span></span><br><span class="line">  <span class="keyword">int</span> numReportsSent;</span><br><span class="line">  <span class="keyword">long</span> brSendStartTime = now();</span><br><span class="line">  <span class="keyword">if</span> (totalBlockCount &lt; dnConf.blockReportSplitThreshold) &#123;</span><br><span class="line">    <span class="comment">// Below split threshold, send all reports in a single message.</span></span><br><span class="line">    numReportsSent = <span class="number">1</span>;</span><br><span class="line">    DatanodeCommand cmd =</span><br><span class="line">      <span class="comment">//***</span></span><br><span class="line">      <span class="comment">//DatanodeProtocolClientSideTranslatorPB bpNamenode</span></span><br><span class="line">      <span class="comment">//bpName是在dn执行的client测的protocol</span></span><br><span class="line">        bpNamenode .blockReport(bpRegistration, bpos.getBlockPoolId(), reports);</span><br><span class="line">  <span class="keyword">return</span> cmds.size() == <span class="number">0</span> ? <span class="keyword">null</span> : cmds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportReceivedDeletedBlocks</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate a list of the pending reports for each storage under the lock</span></span><br><span class="line">		。。</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send incremental block reports to the Namenode outside the lock</span></span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      bpNamenode.blockReceivedAndDeleted(bpRegistration,</span><br><span class="line">          bpos.getBlockPoolId(),</span><br><span class="line">          reports.toArray(<span class="keyword">new</span> StorageReceivedDeletedBlocks[reports.size()]));</span><br><span class="line">      success = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blockReceivedAndDeleted</span><span class="params">(DatanodeRegistration registration,</span></span></span><br><span class="line"><span class="function"><span class="params">      String poolId, StorageReceivedDeletedBlocks[] receivedAndDeletedBlocks)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BlockReceivedAndDeletedRequestProto.Builder builder = </span><br><span class="line">        BlockReceivedAndDeletedRequestProto.newBuilder()</span><br><span class="line">        .setRegistration(PBHelper.convert(registration))</span><br><span class="line">        .setBlockPoolId(poolId);</span><br><span class="line">    <span class="keyword">for</span> (StorageReceivedDeletedBlocks storageBlock : receivedAndDeletedBlocks) &#123;</span><br><span class="line">      StorageReceivedDeletedBlocksProto.Builder repBuilder = </span><br><span class="line">          StorageReceivedDeletedBlocksProto.newBuilder();</span><br><span class="line">      repBuilder.setStorageUuid(storageBlock.getStorage().getStorageID());  <span class="comment">// Set for wire compatibility.</span></span><br><span class="line">      repBuilder.setStorage(PBHelper.convert(storageBlock.getStorage()));</span><br><span class="line">      <span class="keyword">for</span> (ReceivedDeletedBlockInfo rdBlock : storageBlock.getBlocks()) &#123;</span><br><span class="line">        repBuilder.addBlocks(PBHelper.convert(rdBlock));</span><br><span class="line">      &#125;</span><br><span class="line">      builder.addBlocks(repBuilder.build());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      rpcProxy.blockReceivedAndDeleted(NULL_CONTROLLER, builder.build());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ServiceException se) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ProtobufHelper.getRemoteException(se);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>NN获得增量汇报的处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="comment">// DatanodeProtocol</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blockReceivedAndDeleted</span><span class="params">(DatanodeRegistration nodeReg, String poolId,</span></span></span><br><span class="line"><span class="function"><span class="params">    StorageReceivedDeletedBlocks[] receivedAndDeletedBlocks)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  verifyRequest(nodeReg);</span><br><span class="line">  metrics.incrBlockReceivedAndDeletedOps();</span><br><span class="line">  <span class="keyword">if</span>(blockStateChangeLog.isDebugEnabled()) &#123;</span><br><span class="line">    blockStateChangeLog.debug(<span class="string">"*BLOCK* NameNode.blockReceivedAndDeleted: "</span></span><br><span class="line">        +<span class="string">"from "</span>+nodeReg+<span class="string">" "</span>+receivedAndDeletedBlocks.length</span><br><span class="line">        +<span class="string">" blocks."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(StorageReceivedDeletedBlocks r : receivedAndDeletedBlocks) &#123;</span><br><span class="line">    namesystem.processIncrementalBlockReport(nodeReg, poolId, r);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="client和report传递的block-length-来源"><a href="#client和report传递的block-length-来源" class="headerlink" title="client和report传递的block length 来源"></a>client和report传递的block length 来源</h3><h4 id="client"><a href="#client" class="headerlink" title="client"></a>client</h4><p>​    汇报的block_length是发送后接收到ack的大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">block.setNumBytes(one.getLastByteOffsetBlock());</span><br><span class="line">   <span class="comment">// get the packet's last byte's offset in the block</span></span><br><span class="line">   <span class="function"><span class="keyword">long</span> <span class="title">getLastByteOffsetBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> offsetInBlock + dataPos - dataStart;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="report"><a href="#report" class="headerlink" title="report"></a>report</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//会对in做计算，获得block的一些信息</span></span><br><span class="line"><span class="comment">//report的是输入流的信息</span></span><br><span class="line"><span class="comment">//?input大于一个block的处理</span></span><br><span class="line">DataTransferProtocol.receiver.writeBlock(DataInputStream in)</span><br><span class="line">  </span><br><span class="line">DataXceiver.writeBlock(block)</span><br><span class="line">BlockReceiver</span><br><span class="line"> datanode.notifyNamenodeReceivingBlock(block, replicaInfo.getStorageUuid())</span><br><span class="line"> 	bpos.notifyNamenodeReceivingBlock(block, storageUuid);</span><br><span class="line">		actor.notifyNamenodeBlockImmediately(bInfo, storageUuid);</span><br><span class="line"> 			pendingIncrementalBRperStorage.notifyAll();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Add a blockInfo for notification to NameNode. If another entry</span></span><br><span class="line"><span class="comment">     * exists for the same block it is removed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Caller must synchronize access using pendingIncrementalBRperStorage.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bInfo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> storageUuid</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addPendingReplicationBlockInfo</span><span class="params">(ReceivedDeletedBlockInfo bInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        DatanodeStorage storage)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Make sure another entry for the same block is first removed.</span></span><br><span class="line">        <span class="comment">// There may only be one such entry.</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;DatanodeStorage, PerStoragePendingIncrementalBR&gt; entry :</span><br><span class="line">                pendingIncrementalBRperStorage.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getValue().removeBlockInfo(bInfo)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        getIncrementalBRMapForStorage(storage).putBlockInfo(bInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Retrieve the incremental BR state for a given storage UUID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> storageUuid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> PerStoragePendingIncrementalBR <span class="title">getIncrementalBRMapForStorage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            DatanodeStorage storage)</span> </span>&#123;</span><br><span class="line">        PerStoragePendingIncrementalBR mapForStorage =</span><br><span class="line">                pendingIncrementalBRperStorage.get(storage);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mapForStorage == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// This is the first time we are adding incremental BR state for</span></span><br><span class="line">            <span class="comment">// this storage so create a new map. This is required once per</span></span><br><span class="line">            <span class="comment">// storage, per service actor.</span></span><br><span class="line">            mapForStorage = <span class="keyword">new</span> PerStoragePendingIncrementalBR();</span><br><span class="line">            pendingIncrementalBRperStorage.put(storage, mapForStorage);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mapForStorage;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​    </p>
<h3 id="使得blockMap修改的时段"><a href="#使得blockMap修改的时段" class="headerlink" title="使得blockMap修改的时段"></a>使得blockMap修改的时段</h3><p>DFSOutputStream  run（）</p>
<p>申请一个新的block DFSOutputStream nextBlockOutputStream  locateFollowingBlock-》fsNameSystem getAdditionalBlock -》saveAllocatedBlock 新blockid-》FSdir addBlock addBlockCollection -》 blockMap addBlock</p>
<p>此时新分配的block长度为0</p>
<p>DFSOutPutStream   createBlockOutputStream    pipline连接并告知block的大小</p>
<p>DFSOutPutStream</p>
<p>副本写入完成阶段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DFSOutputStream</span> <span class="keyword">extends</span> <span class="title">FSOutputSummer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Syncable</span>, <span class="title">CanSetDropBehind</span> </span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">DataStreamer</span> <span class="keyword">extends</span> <span class="title">Daemon</span> </span>&#123;</span><br><span class="line">			<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseProcessor</span> <span class="keyword">extends</span> <span class="title">Daemon</span> </span>&#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DataStreamer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">long</span> tmpBytesSent = one.getLastByteOffsetBlock();</span><br><span class="line"> <span class="comment">//bytesSent=lastBlock.getNumBytes</span></span><br><span class="line"> <span class="keyword">if</span> (bytesSent &lt; tmpBytesSent) &#123;</span><br><span class="line">    bytesSent = tmpBytesSent;</span><br><span class="line"> &#125;</span><br><span class="line"> endBlock();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the packet's last byte's offset in the block</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getLastByteOffsetBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> offsetInBlock + dataPos - dataStart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">close()&#123;</span><br><span class="line">  	<span class="comment">//传入的参数是最后一个block信息</span></span><br><span class="line">  ExtendedBlock lastBlock = getStreamer().getBlock();</span><br><span class="line">	completeFile(lastBlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">completeFile</span><span class="params">(ExtendedBlock last)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> localstart = Time.now();</span><br><span class="line">  <span class="keyword">long</span> localTimeout = <span class="number">400</span>;</span><br><span class="line">  <span class="keyword">boolean</span> fileComplete = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">int</span> retries = dfsClient.getConf().nBlockWriteLocateFollowingRetry;</span><br><span class="line">  <span class="keyword">while</span> (!fileComplete) &#123;</span><br><span class="line">    <span class="comment">//代理对象</span></span><br><span class="line">    fileComplete =</span><br><span class="line">        dfsClient.namenode.complete(src, dfsClient.clientName, last, fileId);</span><br><span class="line">    <span class="keyword">if</span> (!fileComplete) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> hdfsTimeout = dfsClient.getHdfsTimeout();</span><br><span class="line">      <span class="keyword">if</span> (!dfsClient.clientRunning ||</span><br><span class="line">            (hdfsTimeout &gt; <span class="number">0</span> &amp;&amp; localstart + hdfsTimeout &lt; Time.now())) &#123;</span><br><span class="line">          String msg = <span class="string">"Unable to close file because dfsclient "</span> +</span><br><span class="line">                        <span class="string">" was unable to contact the HDFS servers."</span> +</span><br><span class="line">                        <span class="string">" clientRunning "</span> + dfsClient.clientRunning +</span><br><span class="line">                        <span class="string">" hdfsTimeout "</span> + hdfsTimeout;</span><br><span class="line">          DFSClient.LOG.info(msg);</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IOException(msg);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(localTimeout);</span><br><span class="line">        <span class="keyword">if</span> (retries == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unable to close file because the last block"</span></span><br><span class="line">              + <span class="string">" does not have enough number of replicas."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        retries--;</span><br><span class="line">        localTimeout *= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (Time.now() - localstart &gt; <span class="number">5000</span>) &#123;</span><br><span class="line">          DFSClient.LOG.info(<span class="string">"Could not complete "</span> + src + <span class="string">" retrying..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------blockMap</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Complete in-progress write to the given file.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if successful, false if the client should continue to retry</span></span><br><span class="line"><span class="comment">     *         (e.g if not all blocks have reached minimum replication yet)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException on error (eg lease mismatch, file not open, file deleted)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">completeFile</span><span class="params">(String src, String holder,</span></span></span><br><span class="line"><span class="function"><span class="params">                         ExtendedBlock last, <span class="keyword">long</span> fileId)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> SafeModeException, UnresolvedLinkException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (NameNode.stateChangeLog.isDebugEnabled()) &#123;</span><br><span class="line">            NameNode.stateChangeLog.debug(<span class="string">"DIR* NameSystem.completeFile: "</span> +</span><br><span class="line">                    src + <span class="string">" for "</span> + holder);</span><br><span class="line">        &#125;</span><br><span class="line">        checkBlock(last);</span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">        checkOperation(OperationCategory.WRITE);</span><br><span class="line">        <span class="keyword">byte</span>[][] pathComponents = FSDirectory.getPathComponentsForReservedPath(src);</span><br><span class="line">        writeLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkOperation(OperationCategory.WRITE);</span><br><span class="line">            checkNameNodeSafeMode(<span class="string">"Cannot complete file "</span> + src);</span><br><span class="line">            src = FSDirectory.resolvePath(src, pathComponents, dir);</span><br><span class="line">            success = completeFileInternal(src, holder,</span><br><span class="line">                    ExtendedBlock.getLocalBlock(last), fileId);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeUnlock();</span><br><span class="line">        &#125;</span><br><span class="line">        getEditLog().logSync();</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            NameNode.stateChangeLog.info(<span class="string">"DIR* completeFile: "</span> + src</span><br><span class="line">                    + <span class="string">" is closed by "</span> + holder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">completeFileInternal</span><span class="params">(String src,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         String holder, Block last, <span class="keyword">long</span> fileId)</span> <span class="keyword">throws</span> SafeModeException,</span></span><br><span class="line"><span class="function">            UnresolvedLinkException, IOException </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">hasWriteLock</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">final</span> INodesInPath iip = dir.getLastINodeInPath(src);</span><br><span class="line">        <span class="keyword">final</span> INodeFile pendingFile;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pendingFile = checkLease(src, fileId, holder, iip.getINode(<span class="number">0</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LeaseExpiredException lee) &#123;</span><br><span class="line">            <span class="keyword">final</span> INode inode = dir.getINode(src);</span><br><span class="line">            <span class="keyword">if</span> (inode != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; inode.isFile()</span><br><span class="line">                    &amp;&amp; !inode.asFile().isUnderConstruction()) &#123;</span><br><span class="line">                <span class="comment">// This could be a retry RPC - i.e the client tried to close</span></span><br><span class="line">                <span class="comment">// the file, but missed the RPC response. Thus, it is trying</span></span><br><span class="line">                <span class="comment">// again to close the file. If the file still exists and</span></span><br><span class="line">                <span class="comment">// the client's view of the last block matches the actual</span></span><br><span class="line">                <span class="comment">// last block, then we'll treat it as a successful close.</span></span><br><span class="line">                <span class="comment">// See HDFS-3031.</span></span><br><span class="line">                <span class="keyword">final</span> Block realLastBlock = inode.asFile().getLastBlock();</span><br><span class="line">                <span class="keyword">if</span> (Block.matchingIdAndGenStamp(last, realLastBlock)) &#123;</span><br><span class="line">                    NameNode.stateChangeLog.info(<span class="string">"DIR* completeFile: "</span> +</span><br><span class="line">                            <span class="string">"request from "</span> + holder + <span class="string">" to complete "</span> + src +</span><br><span class="line">                            <span class="string">" which is already closed. But, it appears to be an RPC "</span> +</span><br><span class="line">                            <span class="string">"retry. Returning success"</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> lee;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check the state of the penultimate block. It should be completed</span></span><br><span class="line">        <span class="comment">// before attempting to complete the last one.</span></span><br><span class="line">        <span class="keyword">if</span> (!checkFileProgress(pendingFile, <span class="keyword">false</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// commit the last block and complete it if it has minimum replicas</span></span><br><span class="line">        commitOrCompleteLastBlock(pendingFile, last);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!checkFileProgress(pendingFile, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        finalizeINodeFileUnderConstruction(src, pendingFile,</span><br><span class="line">                iip.getLatestSnapshotId());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">commitOrCompleteLastBlock</span><span class="params">(<span class="keyword">final</span> INodeFile fileINode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">final</span> Block commitBlock)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">hasWriteLock</span><span class="params">()</span></span>;</span><br><span class="line">        Preconditions.checkArgument(fileINode.isUnderConstruction());</span><br><span class="line">        <span class="keyword">if</span> (!blockManager.commitOrCompleteLastBlock(fileINode, commitBlock)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Adjust disk space consumption if required</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> diff = fileINode.getPreferredBlockSize() - commitBlock.getNumBytes();</span><br><span class="line">        <span class="keyword">if</span> (diff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String path = fileINode.getFullPathName();</span><br><span class="line">                dir.updateSpaceConsumed(path, <span class="number">0</span>, -diff * fileINode.getFileReplication());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                LOG.warn(<span class="string">"Unexpected exception while updating disk space."</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Commit the last block of the file and mark it as complete if it has</span></span><br><span class="line"><span class="comment">   * meets the minimum replication requirement</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> bc block collection</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> commitBlock - contains client reported block length and generation</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> true if the last block is changed to committed state.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IOException if the block does not have at least a minimal number</span></span><br><span class="line"><span class="comment">   * of replicas reported from data-nodes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">commitOrCompleteLastBlock</span><span class="params">(BlockCollection bc,</span></span></span><br><span class="line"><span class="function"><span class="params">      Block commitBlock)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(commitBlock == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// not committing, this is a block allocation retry</span></span><br><span class="line">    BlockInfo lastBlock = bc.getLastBlock();</span><br><span class="line">    <span class="keyword">if</span>(lastBlock == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// no blocks in file yet</span></span><br><span class="line">    <span class="keyword">if</span>(lastBlock.isComplete())</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// already completed (e.g. by syncBlock)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> b = commitBlock((BlockInfoUnderConstruction)lastBlock, commitBlock);</span><br><span class="line">    <span class="keyword">if</span>(countNodes(lastBlock).liveReplicas() &gt;= minReplication)</span><br><span class="line">      completeBlock(bc, bc.numBlocks()-<span class="number">1</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Convert a specified block of the file to a complete block.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> bc file</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> blkIndex  block index in the file</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IOException if the block does not have at least a minimal number</span></span><br><span class="line"><span class="comment">   * of replicas reported from data-nodes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> BlockInfo <span class="title">completeBlock</span><span class="params">(<span class="keyword">final</span> BlockCollection bc,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">int</span> blkIndex, <span class="keyword">boolean</span> force)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(blkIndex &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    BlockInfo curBlock = bc.getBlocks()[blkIndex];</span><br><span class="line">    <span class="keyword">if</span>(curBlock.isComplete())</span><br><span class="line">      <span class="keyword">return</span> curBlock;</span><br><span class="line">    BlockInfoUnderConstruction ucBlock = (BlockInfoUnderConstruction)curBlock;</span><br><span class="line">    <span class="keyword">int</span> numNodes = ucBlock.numNodes();</span><br><span class="line">    <span class="keyword">if</span> (!force &amp;&amp; numNodes &lt; minReplication)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Cannot complete block: "</span> +</span><br><span class="line">          <span class="string">"block does not satisfy minimal replication requirement."</span>);</span><br><span class="line">    <span class="keyword">if</span>(!force &amp;&amp; ucBlock.getBlockUCState() != BlockUCState.COMMITTED)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(</span><br><span class="line">          <span class="string">"Cannot complete block: block has not been COMMITTED by the client"</span>);</span><br><span class="line">    BlockInfo completeBlock = ucBlock.convertToCompleteBlock();</span><br><span class="line">    <span class="comment">// replace penultimate block in file</span></span><br><span class="line">    bc.setBlock(blkIndex, completeBlock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Since safe-mode only counts complete blocks, and we now have</span></span><br><span class="line">    <span class="comment">// one more complete block, we need to adjust the total up, and</span></span><br><span class="line">    <span class="comment">// also count it as safe, if we have at least the minimum replica</span></span><br><span class="line">    <span class="comment">// count. (We may not have the minimum replica count yet if this is</span></span><br><span class="line">    <span class="comment">// a "forced" completion when a file is getting closed by an</span></span><br><span class="line">    <span class="comment">// OP_CLOSE edit on the standby).</span></span><br><span class="line">    namesystem.adjustSafeModeBlockTotals(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    namesystem.incrementSafeBlockCount(</span><br><span class="line">        Math.min(numNodes, minReplication));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// replace block in the blocksMap</span></span><br><span class="line">    <span class="keyword">return</span> blocksMap.replaceBlock(completeBlock);</span><br></pre></td></tr></table></figure>
<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>reported length 132928 </p>
<p>block map 11632 </p>
<p>blockMap是client端提交的，是通过</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2018 逆拂
            </div>
            <div class="footer-right">
            other blog:lolvs.cn
	    </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >本页访问数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>